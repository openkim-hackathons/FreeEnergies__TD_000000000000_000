kim init ${modelname} metal unit_conversion_mode

# periodic boundary conditions along all three dimensions
boundary p p p

# Read crystal with 0K lattice parameter.
read_data output/zero_temperature_crystal.dump

# Convert box and all atomic positions to the correct units.
change_box all x scale ${_u_distance} &
               y scale ${_u_distance} &
               z scale ${_u_distance} &
               xy final $(xy*v__u_distance) &
               xz final $(xz*v__u_distance) &
               yz final $(yz*v__u_distance) &
               remap

# Interatomic potential and neighbor settings
kim           interactions ${species}

# set the time step to 0.001 picoseconds
variable      timestep equal 0.001*${_u_time}
timestep      ${timestep}

# Leaving pressure variables just in case we need to compute lattice parameters
variable      temp_converted equal ${temperature}*${_u_temperature}
variable      Tdamp_converted equal ${temperature_damping}*${_u_time}
variable      press_converted equal ${pressure}*${_u_pressure}
variable      Pdamp_converted equal ${pressure_damping}*${_u_time}

# Initialize velocities.
velocity      all create ${temp_converted} ${temperature_seed}

# set NVT ensemble
# if need to print dime, use NPT with aniso barostat
fix           NVT all nvt temp ${temp_converted} ${temp_converted} ${Tdamp_converted}

# compute the time average mean squared displacement and dimension
# ignore the first 5000 timesteps
variable      lx_metal equal lx/${_u_distance}
variable      ly_metal equal ly/${_u_distance}
variable      lz_metal equal lz/${_u_distance}
variable      kB equal 8.617333262e-5 # eV/K
compute       MSD all msd com yes
variable      msd_metal equal c_MSD[4]/${_u_distance}
fix           MSD_AVG all ave/time 5 20 100 v_msd_metal ave running start 5000

# extract fix quantities into variables so they can be used in if-else logic later.
variable      MSD equal f_MSD_AVG

variable      spring_constant equal $(3*kB*f_MSD_AVG/(f_MSD_AVG)^2)

# set error bounds for temperature and pressure in original metal units (K and bar)
variable      T_low equal  "{rpls_temp} - 1.0"
variable      T_up  equal  "{rpls_temp} + 1.0"
variable      P_low equal  "{rpls_press} - 5.0"
variable      P_up  equal  "{rpls_press} + 5.0"

# print to logfile every 1000 timesteps
thermo_style  custom step etotal v_etotal_metal pe v_pe_metal &
              temp v_T_metal lx v_lx_metal press v_P_metal c_c1[4] v_msd_metal
thermo        1000

# Temperature may be off because of rigid bodies or SHAKE constraints.
# See https://docs.lammps.org/velocity.html
run 0
velocity all scale $(v_temperature*v__u_temperature)

# Set up convergence check with kim-convergence.
python run_length_control input 6 SELF 1 variable vol_metal variable temp_metal format pissss file run_length_control_preFL.py

# Run until converged.
python run_length_control invoke

# Run a simulation for at most 2000*1000 timesteps. At each 1000th time step, check
# whether the temperature and pressure have converged. If yes, break.
label top
variable a loop 2000
run 1000
if "${{lx_metal}}>${{lx0_metal_times1000}}" then "jump SELF unstable"
if "${{T}}>${{T_low}} && ${{T}}<${{T_up}} && ${{P}}>${{P_low}} && ${{P}}<${{P_up}}" then "jump SELF break"
print "flag: Temp = ${{T}}, Press = ${{P}}"
next a
jump SELF top
label break

# Write final averaged volume to file if temperature and volume have converged; otherwise write a
# flag to indicate non-convergence.
variable      myStep equal step
if "${{myStep}} < 2000000" then "print '${{LX}} ${{MSD}}' file {rpls_output_file}"
else  "print 'not_converged' file {rpls_output_file}"

print "LAMMPS calculation completed"
quit 0

# unstable
label unstable
print "ERROR: System volume ${{lx_metal}} A has become larger than ${{lx0_metal_times1000}} A. Aborting calculation."
