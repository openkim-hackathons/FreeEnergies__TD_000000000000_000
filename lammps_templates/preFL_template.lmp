
        kim init ${modelname} metal unit_conversion_mode

        # periodic boundary conditions along all three dimensions
        boundary p p p

        # Read crystal with 0K lattice parameter.
        read_data output/zero_temperature_crystal.dump

        # Change to triclinic box. Necessary for triclinic barostat, but inflates mean squared displacement
        #change_box all triclinic remap

        # Convert box and all atomic positions to the correct units.
        #change_box all x scale ${_u_distance} &
        #               y scale ${_u_distance} &
        #               z scale ${_u_distance} &
        #               xy final $(xy*v__u_distance) &
        #               xz final $(xz*v__u_distance) &
        #               yz final $(yz*v__u_distance) &
        #               remap

        # Interatomic potential and neighbor settings
        kim           interactions ${species}

        # set the time step to 0.001 picoseconds
        variable      timestep_converted equal ${timestep}*${_u_time}
        timestep      ${timestep_converted}

        # Leaving pressure variables just in case we need to compute lattice parameters
        variable      temp_converted equal ${temperature}*${_u_temperature}
        variable      Tdamp_converted equal ${temperature_damping}*${_u_time}
        variable      press_converted equal ${pressure}*${_u_pressure}
        variable      Pdamp_converted equal ${pressure_damping}*${_u_time}

        # Initialize velocities.
        velocity      all create ${temp_converted} ${temperature_seed}

        # Set thermodynamic ensemble (barostat type depends on box type)
        fix          ensemble all npt temp ${temp_converted} ${temp_converted} ${Tdamp_converted} aniso ${press_converted} ${press_converted} ${Pdamp_converted}
        compute cl all temp/com
        fix_modify ensemble temp cl

        # compute box information
        variable       lx_metal equal lx/${_u_distance}
        variable       ly_metal equal ly/${_u_distance}
        variable       lz_metal equal lz/${_u_distance}
        variable       xy_metal equal xy/${_u_distance}
        variable       yz_metal equal yz/${_u_distance}
        variable       xz_metal equal xz/${_u_distance}

        # compute mean squared displacement
        #compute       MSD all msd com yes average yes
        
        group 1 type 1
        compute           MSD0 1 msd com yes average yes
        

        # Temperature may be off because of rigid bodies or SHAKE constraints. See https://docs.lammps.org/velocity.html
        #run 0
        #velocity all scale $(v_temperature*v__u_temperature)

        # Initialize measurement of box vectors
        #thermo_style custom avecx avecy avecz bvecx bvecy bvecz cvecx cvecy cvecz temp press vol etotal step
        #thermo_style custom lx ly lz xy yz xz temp press vol etotal c_MSD0[4] c_MSD1[4] step
        
        thermo_style custom lx ly lz xy yz xz temp press vol etotal c_MSD0[4] step
        
        thermo 1000

        # Set up convergence check with kim-convergence.
        # Alternative is to set a safe general equilibration time
        # More important for expensive potentials
        #python run_length_control input 6 SELF 1 variable msd_metal format pissss file run_length_control_preFL.py

        # Run until converged.
        #python run_length_control invoke

        # Equilibration
        #run 10000

        variable N_every equal 100
        variable run_time equal 20000
        variable N_repeat equal v_run_time/(2*v_N_every)
        variable N_start equal v_run_time/2

        # compute averages of above variables
        #fix           AVG all ave/time ${N_every} ${N_repeat} ${run_time} v_lx_metal v_ly_metal v_lz_metal c_MSD[4] ave running start ${N_start}
                                                    #v_bvecx_metal v_bvecy_metal v_bvecz_metal &
                                                    #v_cvecx_metal v_cvecy_metal v_cvecz_metal &
                                                    #c_MSD[4] ave running
        
        fix          AVG all ave/time ${N_every} ${N_repeat} ${run_time} v_lx_metal v_ly_metal v_lz_metal v_xy_metal v_yz_metal v_xz_metal c_MSD0[4] ave running start ${N_start}
        

        # Run steps in the converged regime.
        run ${run_time}

        # compute spring constant
        variable      kB equal 8.617333262e-5*(v__u_energy/v__u_temperature) # eV/K unless converted
        #variable      MSD equal f_AVG[4]*(v__u_distance)^2
        #variable      spring_constant equal $(3*v_kB*v_temp_converted/(v_MSD)^2)
        
        variable      MSD0 equal f_AVG[7]*(v__u_distance)^2
        variable      spring_constant_0 equal $(3*v_kB*v_temp_converted/(v_MSD0)^2)
        

        # Write final averages and spring constant
        #print "# xx | xy | xz | yx | yy | yz | zx | zy | zz | spring constant [eV/Ang^2]" file ${output_filename}
        #print "$(f_AVG[1]) $(f_AVG[2]) $(f_AVG[3]) $(f_AVG[4]) $(f_AVG[5]) $(f_AVG[6]) $(f_AVG[7]) $(f_AVG[8]) $(f_AVG[9]) ${spring_constant}" screen no append ${output_filename}
        print "# lx | ly | lz [Ang] | vol [Ang^3] | spring constant [eV/Ang^2]" file ${output_filename}
        #print "$(f_AVG[1]) $(f_AVG[2]) $(f_AVG[3]) $(vol) ${spring_constant}" screen no append ${output_filename}
        
        print "$(f_AVG[1]) $(f_AVG[2]) $(f_AVG[3]) $(f_AVG[4]) $(f_AVG[5]) $(f_AVG[6]) $(vol) $(v_spring_constant_0)" screen no append ${output_filename}
        

        # Reset.
        unfix ensemble
        unfix AVG
        #unfix cr_fix  # From run_length_control.py
        reset_timestep 0

        # Write the initial starting file for a true simulation.
        write_restart ${write_restart_filename}



        