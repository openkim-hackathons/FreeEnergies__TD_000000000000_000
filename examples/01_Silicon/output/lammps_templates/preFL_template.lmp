
        kim init ${modelname} metal unit_conversion_mode

        # periodic boundary conditions along all three dimensions
        boundary p p p

        # Read crystal with 0K lattice parameter.
        read_data output/zero_temperature_crystal.data

        # Increase maximum number of neighbors allowed per atom (for potentials that support many species)
        neigh_modify delay 0 every 1 check yes one 2000

        # Change to triclinic box.
        change_box all triclinic

        # Interatomic potential and neighbor settings
        kim           interactions ${species}

        # set the time step to 0.001 picoseconds
        variable      timestep_converted equal ${timestep}*${_u_time}
        timestep      ${timestep_converted}

        # Convert temperature and pressure units
        variable      temp_converted equal ${temperature}*${_u_temperature}
        variable      Tdamp_converted equal ${temperature_damping}*${_u_time}
        variable      press_converted equal ${pressure}*${_u_pressure}
        variable      Pdamp_converted equal ${pressure_damping}*${_u_time}

        # Initialize velocities.
        velocity      all create ${temp_converted} ${temperature_seed}

        # Run NPT ensemble (barostat type depends on box type)
        fix          ensemble all npt temp ${temp_converted} ${temp_converted} ${Tdamp_converted} tri ${press_converted} ${press_converted} ${Pdamp_converted}
        compute      cl all temp/com
        fix_modify   ensemble temp cl

        # Temperature may be off because of rigid bodies or SHAKE constraints. See https://docs.lammps.org/velocity.html
        run 0
        velocity all scale ${temp_converted}

        # compute box information
        variable       lx_metal equal lx/${_u_distance}
        variable       ly_metal equal ly/${_u_distance}
        variable       lz_metal equal lz/${_u_distance}
        variable       xy_metal equal xy/${_u_distance}
        variable       yz_metal equal yz/${_u_distance}
        variable       xz_metal equal xz/${_u_distance}
        variable       vol_metal equal vol/(${_u_distance}^3)

        # Short run to equilibrate MSD
        compute msd all msd com yes
        thermo_style custom lx ly lz xy yz xz temp press vol etotal c_msd[4] step
        thermo 1000
        run 5000
        reset_timestep 0

        # Compute slope of mean squared displacement to detect diffusion
        fix msd_vector all vector 100 c_msd[4]
        variable msd_slope equal slope(f_msd_vector)

        # Thermodynamic output
        thermo_style custom lx ly lz xy yz xz temp press vol etotal c_msd[4] v_msd_slope step
        thermo 1000
        
        # Before kim-convergence, perform a short run and decide whether or not to quit
        run 5000
        if "${msd_slope} > ${msd_threshold}" then "write_dump all atom output/melted_crystal.dump" &
                                      "print 'Crystal melted or vaporized'" &
                                      "quit"
        unfix msd_vector
        reset_timestep 0
        thermo_style custom lx ly lz xy yz xz temp press vol etotal step

        # Set up convergence check with kim-convergence.
        python run_length_control input 16 SELF 1 variable vol_metal variable lx_metal variable ly_metal variable lz_metal variable xy_metal variable xz_metal variable yz_metal format pissssssssssssss file ${run_length_control}

        # Run until converged (minimum runtime 30000 steps)
        python run_length_control invoke

        unfix cr_fix # From run_length_control.py
        reset_timestep 0

        print 'Kim-convergence finished'

        # Compute mean squared displacement
        #set group all image 0 0 0
        
        group 1 type 1
        compute           MSD0 1 msd com yes
        

        # New set of values to print to log file
        
        thermo_style custom lx ly lz xy yz xz temp press vol etotal c_MSD0[4] step
        

        # Define variables for fix ave/time
        variable N_every equal 100 # sample msd at intervals of this many steps
        variable run_time equal 50000 # can be an input variable
        variable N_repeat equal v_run_time/(2*v_N_every)
        variable N_start equal v_run_time/2

        # compute averages of box vectors and msd
        
        fix          AVG all ave/time ${N_every} ${N_repeat} ${run_time} v_lx_metal v_ly_metal v_lz_metal v_xy_metal v_yz_metal v_xz_metal c_MSD0[4] ave running start ${N_start}
        

        # Compute unwrapped atom positions
        compute unwrapped all property/atom xu yu zu

        variable xu atom c_unwrapped[1]
        variable yu atom c_unwrapped[2]
        variable zu atom c_unwrapped[3]

        # Average unwrapped atom positions
        fix avePos all ave/atom ${N_every} $(v_run_time/v_N_every) ${run_time} v_xu v_yu v_zu

        # Run steps in the converged regime.
        run ${run_time}

        # compute spring constant
        variable      kB equal (8.617333262e-5)*(v__u_energy/v__u_temperature) # eV/K unless converted
        
        variable      MSD0 equal f_AVG[7]*(v__u_distance)^2
        variable      spring_constant_0 equal $(3*v_kB*v_temp_converted/(v_MSD0))
        

        # Write final averages and spring constant
        print "# lx | ly | lz [Ang] | vol [Ang^3] | spring constant [eV/Ang^2]" file ${output_filename}
        
        print "$(f_AVG[1]) $(f_AVG[2]) $(f_AVG[3]) $(f_AVG[4]) $(f_AVG[5]) $(f_AVG[6]) $(vol) $(v_spring_constant_0)" screen no append ${output_filename}
        

        # Write the initial starting file for a true simulation.
        write_restart ${write_restart_filename}

        # Create per-atom variables for averaged positions
        variable ave_x atom f_avePos[1]
        variable ave_y atom f_avePos[2]
        variable ave_z atom f_avePos[3]

        # Set box dimensions to time-averaged dimensions
        change_box all x scale $(f_AVG[1]/lx) y scale $(f_AVG[2]/ly) z scale $(f_AVG[3]/lz) xy final $(f_AVG[4]) yz final $(f_AVG[5]) xz final $(f_AVG[6]) remap

        # Set atom positions to time-averaged positions
        set group all x v_ave_x y v_ave_y z v_ave_z

        # Reset.
        unfix ensemble
        unfix AVG
        #unfix ave_x
        #unfix ave_y
        #unfix ave_z
        unfix avePos
        #unfix cr_fix  # From run_length_control.py
        reset_timestep 0

        # Write data file of averaged positions and box dimensions
        write_data ${write_data_filename}
        